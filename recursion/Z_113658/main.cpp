#include <iostream>
using namespace std;

/*! \details Возвращает количество символов, введенных пользователем.
Функция выполняется в два этапа. На первом этапе из потока вычитывается код
первого символа. На втором этапе выполняется рекурсивный вызов функции, что
приводит к последовательному чтению символов из потока до появления символа
перевода строки, с сохранением этих символов на стеке вызовов в переменной ch.
При опустошении стека, выполняется последовательное возвращение
символов в поток ввода (cin) вызовом cin.putback().
*/
int getInputLength(int pos)
{
    /*
    Если в потоке первым символом является перевод строки, то
    рекурсивный вызов функции прекращается, возвращается сумма накопленная
    в переменной pos
    */
    if(cin.peek() == '\n')
        return pos;
    /*
    Получение первого символа из потока.
    Если получено отрицательное значение, то в потоке нет символов, что
    приводит к завершению рекурсивных вызовов функции.
    Иначе выполняется преобразование полученного символа к типу char.
    */
    int c = cin.get();
    if( c == -1)
        return pos;
    char ch = static_cast<char>(c);
    /*
    Далее выполняется рекурсивный вызов функции с увеличенным на единицу
    счетчиком символов.
    */
    int res = getInputLength(++pos);

    cin.putback(ch);
    return res;
}

/*! \details Возвращает символ, предшествующий символу перевода строки из потока
ввода cin. В функции используется рекурсивный вызов.
*/
char getLast()
{
    int c = cin.get();
    char ch = static_cast<char>(c);
    if(cin.peek() != '\n')
    {
        char t = getLast();
        cin.putback(ch);
        ch = t;
    }
    return ch;
}

/*!  \brief Оптимизация строки введенной пользователем.
\details Для оптимизации выполняется чтение первого и последнего символов из
потока cin, выявление совпадений. Если совпадения нет, то символ выводится в cout.
Иначе символы пропускаются.
Рекурсивный вызов функции позволяет получать два зеркально расположенных символа.
*/
void optimizer(int cnt)
{
    /*
    Если cnt равно нулю, то обработана половина строки. В таком случае
    останавливается рекурсивный вызов функции.
    */
    if(cnt == 0)
        return;
    /*
    Вычитывается следующий символ из потока cin.
    */
    int c = cin.get();
    char ch = static_cast<char>(c);
    /*
    Если счетчик cnt равен единице, то количество введённых символом не четно.
    В таком случае выводится символ, расположенный в середине строки, и
    останавливается рекурсивный вызов функции.
    */
    if(cnt == 1)
    {
        cout << ch;
        return;
    }
    char en = getLast();
    if(ch != en)
        cout << ch;
    cnt -= 2;
    optimizer(cnt);
    /*
    К этому моменту уже выведены оптимизированные символы левой половины строки.
    Далее выводится правая половина строки, с учетом совпадения символов.
    */
    if(ch != en)
    {
        cout << en;
    }
}

int main()
{   
    int len = getInputLength(0);
    optimizer(len);
    return 0;
}
